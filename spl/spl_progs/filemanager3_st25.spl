//Functions : BUFFERED_WRITE(1), BUFFERED_READ(2), OPEN(3), CLOSE(4)
// **** All functions in this module expect that the inode is locked before they are called.

alias functionNum R1;



// ---- BUFFERED_WRITE
// Args - Disk Block Number, Offset, Word
// Return NIL
// Called by the Write system call.
if(functionNum == 1) then

    alias diskBlockNumber R5;
    alias offset R6;
    alias word R7;

    diskBlockNumber = R2;
    offset = R3;
    word = R4;

    // Identify the buffer : Buffer Number = (Disk Number % 4)
    alias bufferNumber R8;
    bufferNumber = diskBlockNumber % 4;

    // Acquire the buffer by calling the Acquire_Buffer() function
    R1 = ACQUIRE_BUFFER;
    R2 = bufferNumber;
    R3 = [SYSTEM_STATUS_TABLE + 1];
    multipush(R5, R6, R7, R8);
    call RESOURCE_MANAGER;
    multipop(R5, R6, R7, R8);
    alias bufferEntry R9;
    bufferEntry = BUFFER_TABLE + bufferNumber*4;

    // check if buffer contains a different disk block
    if([bufferEntry] != diskBlockNumber) then

        // if (the buffer contents are dirty) (check DIRTY BIT of buffer table )
        if([bufferEntry + 1] == 1) then

            // Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module
            R1 = 1;
            R2 = [SYSTEM_STATUS_TABLE+1];
            R3 = BUFFER_BASE + bufferNumber;
            R4 = [bufferEntry];
            multipush(R5, R6, R7, R8, R9);
            call DEVICE_MANAGER;
            multipop(R5, R6, R7, R8, R9);

            // Mark the buffer as clean in the corresponding buffer table entry
            [bufferEntry + 1] = 0;
        endif;

        // Load the required disk block into the buffer by invoking the disk_load() function in the device manager module
        R1 = 2;
        R2 = [SYSTEM_STATUS_TABLE+1];
        R3 = BUFFER_BASE + bufferNumber;
        R4 = diskBlockNumber;
        multipush(R5, R6, R7, R8, R9);
        call DEVICE_MANAGER;
        multipop(R5, R6, R7, R8, R9);

        // Set the new Disk block number in the Buffer table entry
        [bufferEntry] = diskBlockNumber;

    endif;

    //Write the contents of the word taken as input into the offset location in the buffer
    [(BUFFER_BASE + bufferNumber)*512 + offset] = word;

    //print "word";
    //print [(BUFFER_BASE + bufferNumber)*512 + offset];

    // Mark the buffer as Dirty
    [bufferEntry + 1] = 1;

    // Release the buffer by calling the Release_Buffer() function in the Resource Manager module;
    R1 = RELEASE_BUFFER	;
    R2 = bufferNumber;
    R3 = [SYSTEM_STATUS_TABLE + 1];
    call RESOURCE_MANAGER;

    return;
endif;




// ---- BUFFERED_READ
// Args - Disk Block Number, Offset, Memory Address
// Return NIL
// Called by Read system call.
if(functionNum == 2) then

    alias diskBlockNumber R5;
    alias offset R6;
    alias memoryAddress R7;

    diskBlockNumber = R2;
    offset = R3;
    memoryAddress = R4;

    // Identify the buffer : Buffer Number = (Disk Number % 4)
    alias bufferNumber R8;
    bufferNumber = diskBlockNumber % 4;

    // Acquire the buffer by calling the Acquire_Buffer() function
    R1 = ACQUIRE_BUFFER;
    R2 = bufferNumber;
    R3 = [SYSTEM_STATUS_TABLE + 1];
    multipush(R5, R6, R7, R8);
    call RESOURCE_MANAGER;
    multipop(R5, R6, R7, R8);
    alias bufferEntry R9;
    bufferEntry = BUFFER_TABLE + bufferNumber*4;

    // check if buffer contains a different disk block
    if([bufferEntry] != diskBlockNumber) then

        // if (the buffer contents are dirty) (check DIRTY BIT of buffer table )
        if([bufferEntry + 1] == 1) then

            // Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module
            R1 = 1;
            R2 = [SYSTEM_STATUS_TABLE+1];
            R3 = BUFFER_BASE + bufferNumber;
            R4 = [bufferEntry];
            multipush(R5, R6, R7, R8, R9);
            call DEVICE_MANAGER;
            multipop(R5, R6, R7, R8, R9);

            // Mark the buffer as clean in the corresponding buffer table entry
            [bufferEntry + 1] = 0;
        endif;


        // Load the required disk block into the buffer by invoking the disk_load() function in the device manager module
        R1 = 2;
        R2 = [SYSTEM_STATUS_TABLE+1];
        R3 = BUFFER_BASE + bufferNumber;
        R4 = diskBlockNumber;
        multipush(R5, R6, R7, R8, R9);
        call DEVICE_MANAGER;
        multipop(R5, R6, R7, R8, R9);

        // Set the new Disk block number in the Buffer table entry
        [bufferEntry] = diskBlockNumber;

    endif;

    // Copy the contents in the offset location in the buffer to the physical address given as input; 
    [memoryAddress] = [(BUFFER_BASE + bufferNumber)*512 + offset];

    // Release the buffer by calling the Release_Buffer() function in the Resource Manager module;
    R1 = RELEASE_BUFFER;
    R2 = bufferNumber;
    R3 = [SYSTEM_STATUS_TABLE + 1];
    call RESOURCE_MANAGER;

    return;
endif;




// ---- OPEN
// Args - File Name, Return - Open File Table Index, -1 or -2
// locate file in the inode table, make an entry in open file table.
// called by open system call (after getting entry in per-process resource table)

if(functionNum == 3) then

    alias filename R2;

    //find indode entry of file
    alias cnt R5;
    cnt = 0;
    while( cnt < 60 ) do
        if( [INODE_TABLE + 16*cnt + 1] == filename ) then
            break;
        endif ;
        cnt = cnt + 1;
    endwhile ;

    //no file entry found in inode table
    if(cnt == 60) then
        R0 = -1;
        return;
    endif;

    alias inodeIndex R6;
    inodeIndex = cnt;
    //print "1";

    // lock file
    // CALL ACQUIRE_INODE, RESOURCE MANAGER 0
    R1 = 4;
    R2 = inodeIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    multipush(R2, R6);
    call RESOURCE_MANAGER;
    multipop(R2, R6);
    //print "2";

    //locking fails
    if(R0 == -1) then
        return;
    endif;

    //if file not DATA file return -1 (Only data files can be opened)
    if( [INODE_TABLE + 16*inodeIndex + 0] == EXEC ) then
        // release lock on file
        // CALL RELEASE_INODE, RESOURCE MANAGER 0
        R1 = 5;
        R2 = inodeIndex;
        R3 = [SYSTEM_STATUS_TABLE+1];
        multipush(R2 ,R6);
        call RESOURCE_MANAGER;
        multipop(R2, R6);

        R0 = -1;
        return;
    endif ;
    //print "3";

    // find free entry in Open File Table
    cnt = 0;
    while( cnt < 32 ) do
        if( [OPEN_FILE_TABLE + 4*cnt ] == -1 ) then
            break;
        endif ;
        cnt = cnt + 1;
    endwhile ;

    //no free entry
    if(cnt == 32) then
        // release lock on file
        // CALL RELEASE_INODE, RESOURCE MANAGER 0
        R1 = 5;
        R2 = inodeIndex;
        R3 = [SYSTEM_STATUS_TABLE+1];
        multipush(R2, R6);
        call RESOURCE_MANAGER;
        multipop(R2, R6);

        R0 = -2;
        return;
    endif;
    //print "4";

    alias openFileIndex R7;
    openFileIndex = cnt;

    if (filename == "root") then
        [OPEN_FILE_TABLE + 4*openFileIndex] = INODE_ROOT;
    else
        //if the File Open Count is -1, set it to 1. Otherwise, increment the File Open Count.

        if([FILE_STATUS_TABLE + 4*inodeIndex + 1] == -1) then
            [FILE_STATUS_TABLE + 4*inodeIndex + 1] = 1;
        else
            [FILE_STATUS_TABLE + 4*inodeIndex + 1] = [FILE_STATUS_TABLE + 4*inodeIndex + 1] + 1;
        endif;

        [OPEN_FILE_TABLE + 4*openFileIndex] = inodeIndex;
    endif;

    //OPEN INSTANCE COUNT to 1 and LSEEK to 0
    [OPEN_FILE_TABLE + 4*openFileIndex + 1] = 1;
    [OPEN_FILE_TABLE + 4*openFileIndex + 2] = 0;
    //print "5";
    // release lock on file
    // CALL RELEASE_INODE, RESOURCE MANAGER 0
    R1 = 5;
    R2 = inodeIndex;
    R3 = [SYSTEM_STATUS_TABLE+1];
    multipush(R2, R6, R7);
    call RESOURCE_MANAGER;
    multipop(R2, R6, R7);
    //print "6";

    R0 = openFileIndex;
    return;

endif;





// ---- CLOSE
// Args - File Table Index, Return NIL
// closes the open instance of a file
// called by close, exit system call.
if(functionNum == 4) then

    alias openFileIndex R2;

    alias inodeIndex R5;
    inodeIndex = [OPEN_FILE_TABLE + 4*openFileIndex];


    // decrement Open Instance Count
    [OPEN_FILE_TABLE + 4*openFileIndex + 1] = [OPEN_FILE_TABLE + 4*openFileIndex + 1] - 1;

    // If Open Instance Count becomes 0, 
    if([OPEN_FILE_TABLE + 4*openFileIndex + 1] == 0) then

        // invalidate entry by setting all fields to -1.
        [OPEN_FILE_TABLE + 4*openFileIndex + 0] = -1;
        [OPEN_FILE_TABLE + 4*openFileIndex + 1] = -1;
        [OPEN_FILE_TABLE + 4*openFileIndex + 2] = -1;
        [OPEN_FILE_TABLE + 4*openFileIndex + 3] = -1;

        // if file is not "root", decrement File Open Count in File (Inode) Status Table.
        if ([INODE_TABLE + 16*inodeIndex + 1] != "root") then
            [FILE_STATUS_TABLE + 4*inodeIndex + 1] = [FILE_STATUS_TABLE + 4*inodeIndex + 1] - 1;
        endif;

        // if File Open Count in File Status Table becomes 0, set it to -1.
        if([FILE_STATUS_TABLE + 4*inodeIndex + 1] == 0) then
            [FILE_STATUS_TABLE + 4*inodeIndex + 1] = -1;
        endif;
    endif;
    
    return;
endif;




// // -------- FILE MANAGER: BUFFERED_WRITE(1), BUFFERED_READ(2), OPEN(3), CLOSE(4) -----------------
// // All functions in this module *expect* that the inode is LOCKED before they are called.

// alias functionNum R1;

// //----------------------BUFFERED_WRITE(1)-----------------------
// if(functionNum == 1) then
//     // Args:
// 	alias disk_block_num R2;
// 	alias offset R3;
// 	alias word R4;

//     // Identify the Buffer Number
// 	alias buffer_num R5;
// 	alias bufferTableEntry R6;
// 	buffer_num = disk_block_num % 4;
// 	bufferTableEntry = BUFFER_TABLE + 4*buffer_num;

//     // Calling Acquire Buffer() in Resource Manager
//     // Args:
//     // funNum = 1, buffer number, PID
// 	multipush(R1,R2,R3,R4,R5,R6);
// 		R1 = 1;
// 		R2 = buffer_num;
// 		R3 = [SYSTEM_STATUS_TABLE + 1];
// 		call MOD_0;
// 	multipop(R1,R2,R3,R4,R5,R6);

//    // Check if Buffer in Buffer Table has Different Disk Block
// 	if([bufferTableEntry + 0] != disk_block_num) then
//         // If Buffer Contents are Dirty
//         // then call Disk Store in Device Manager to store contents of Buffer to Disk
//         // Args: FunNum, PID, Page Number (from BUFFER_BASE + buffer_num offset PAGE of Buffer Cache), Block Number
// 		if([bufferTableEntry + 1] == 1) then
// 	        multipush(R1,R2,R3,R4,R5,R6);
// 			R1 = DISK_STORE;
// 			R3 = BUFFER_BASE + buffer_num;
// 			R4 = [bufferTableEntry + 0];
//             R2 = [SYSTEM_STATUS_TABLE + 1];
// 			call MOD_4;
// 			multipop(R1,R2,R3,R4,R5,R6);
//             //Mark the buffer as clean (DIRTY = 0) in the corresponding buffer table entry;
// 			[bufferTableEntry + 1] = 0;
// 		endif;

//         // Load the Required Disk Block Num into the Buffer Block Page
//         // Calling Disk Load Function in Device Manager
//         // Args: FunNum, PID, Page Number (from BUFFER_BASE + buffer_num offset PAGE of Buffer Cache), Block Number
//         multipush(R1,R2,R3,R4,R5,R6);
//         R1 = DISK_LOAD;
//         R4 = disk_block_num;			
//         R3 = BUFFER_BASE + buffer_num;		
//         R2 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_4;
//         multipop(R1,R2,R3,R4,R5,R6);	

//         // Set the new disk_block_num in Buffer Table Entry
//         [bufferTableEntry + 0] = disk_block_num;
// 	endif;
    
//     // Write the contents of the word taken as input into the offset location in the buffer
//     [BUFFER + buffer_num*512 + offset] = word;

//     //Mark the buffer as DIRTY = 1 in the corresponding buffer table entry;
// 	[bufferTableEntry + 1] = 1;

//     //calling RELEASE_BUFFER
// 	multipush(R1,R2,R3,R4,R5,R6);
// 		R1 = RELEASE_BUFFER;
// 		R2 = buffer_num;
// 		R3 = [SYSTEM_STATUS_TABLE + 1];
// 		call MOD_0;
// 	multipop(R1,R2,R3,R4,R5,R6);	
// 	return;
// endif;

// //----------------------BUFFERED_READ(2)-----------------------
// if(functionNum == 2) then
//     // Args:
// 	alias disk_block_num R2;
// 	alias offset R3;
// 	alias physicalAddress R4;

//     // Identify the Buffer Number
// 	alias buffer_num R5;
// 	alias bufferTableEntry R6;
// 	buffer_num = disk_block_num % 4;
// 	bufferTableEntry = BUFFER_TABLE + 4*buffer_num;

//     // Calling Acquire Buffer() in Resource Manager
//     // Args:
//     // funNum = 1, buffer number, PID
// 	multipush(R1,R2,R3,R4,R5,R6);
// 		R1 = 1;
// 		R2 = buffer_num;
// 		R3 = [SYSTEM_STATUS_TABLE + 1];
// 		call MOD_0;
// 	multipop(R1,R2,R3,R4,R5,R6);

//     // Check if Buffer in Buffer Table has Different Disk Block
// 	if([bufferTableEntry + 0] != disk_block_num) then
//         // If Buffer Contents are Dirty
//         // then call Disk Store in Device Manager to store contents of Buffer to Disk
//         // Args: FunNum, PID, Page Number (from BUFFER_BASE + buffer_num offset PAGE of Buffer Cache), Block Number
// 		if([bufferTableEntry + 1] == 1) then
// 	        multipush(R1,R2,R3,R4,R5,R6);
// 			R1 = DISK_STORE;
// 			R3 = BUFFER_BASE + buffer_num;
// 			R4 = [bufferTableEntry + 0];
//             R2 = [SYSTEM_STATUS_TABLE + 1];
// 			call MOD_4;
// 			multipop(R1,R2,R3,R4,R5,R6);
//             //Mark the buffer as clean (DIRTY = 0) in the corresponding buffer table entry;
// 			[bufferTableEntry + 1] = 0;
// 		endif;

//         // Load the Required Disk Block Num into the Buffer Block Page
//         // Calling Disk Load Function in Device Manager
//         // Args: FunNum, PID, Page Number (from BUFFER_BASE + buffer_num offset PAGE of Buffer Cache), Block Number
//         multipush(R1,R2,R3,R4,R5,R6);
//         R1 = DISK_LOAD;
//         R4 = disk_block_num;			
//         R3 = BUFFER_BASE + buffer_num;		
//         R2 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_4;
//         multipop(R1,R2,R3,R4,R5,R6);	

//         // Set the new disk_block_num in Buffer Table Entry
//         [bufferTableEntry + 0] = disk_block_num;
// 	endif;

//     // Copy the contents in the offset location in the buffer to the physical address given as input
// 	[physicalAddress] = [BUFFER + buffer_num*512 + offset];

//     //calling RELEASE_BUFFER
// 	multipush(R1,R2,R3,R4,R5,R6);
// 		R1 = RELEASE_BUFFER;
// 		R2 = buffer_num;
// 		R3 = [SYSTEM_STATUS_TABLE + 1];
// 		call MOD_0;
// 	multipop(R1,R2,R3,R4,R5,R6);	
// 	return;
// endif;



// // ------ OPEN(funNum = 3) -------------------------------------------
// // Update the file status table and 
// // the open file table when a file is opened
// // Args: 
// // 1. fileName
// // Returns:
// // Open File Table Index, -1 or -2

// if( functionNum == 3 ) then
//     // Args:
//     alias fileName R2;

//     alias inodeTableIndex R5;
//     inodeTableIndex = 0;
//     while ( inodeTableIndex < 60 ) do 
//         if( [INODE_TABLE + inodeTableIndex*16 + 1] == fileName ) then
//             break;
//         endif;
//         inodeTableIndex = inodeTableIndex + 1;
//     endwhile;
//     if( inodeTableIndex == 60 ) then
//         // File of the given fileName doesnt exist
//         R0 = -1;
//         return;
//     endif;

//     // /* Lock the inode */
//     // Calling Acquire_Inode() Resource Manager
//     // Args:
//     // funNum = 4, inodeTableIndex, PID
//     multipush(R1,R2,R3,R5);
//         R1 = 4;
//         R2 = inodeTableIndex;
//         R3 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_0;
//     multipop(R1,R2,R3,R5);
//     if(R0 == -1) then
//         // Acquiring/Locking Inode Failed
//         return;
//     endif;

//     // /* Only data files can be opened */
//     // Calling Release_Inode() Resource Manager otherwise
//     // Args:
//     // funNum = 5, inodeTableIndex, PID
//     if([inodeTableIndex + 0] == EXEC) then
//         multipush(R1,R2,R3,R5);
//         R1 = 5;
//         R2 = inodeTableIndex;
//         R3 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_0;
//         multipop(R1,R2,R3,R5);
//         R0 = -1;
//         return;
//     endif;

//     // ---- Find A Free Open File Table Entry ------- 
//     alias openFileTableIndex R6;
//     openFileTableIndex = 0;
//     while(openFileTableIndex < 32) do 
//         if([OPEN_FILE_TABLE + openFileTableIndex*4 + 0] == -1) then
//             break;
//         endif;
//         openFileTableIndex = openFileTableIndex + 1;
//     endwhile;
//     if(openFileTableIndex == 32) then
//         // Maximum number of open files reached
//         // call release_inode() and return -2
//         multipush(R1,R2,R3,R5);
//         R1 = 5;
//         R2 = inodeTableIndex;
//         R3 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_0;
//         multipop(R1,R2,R3,R5);
//         R0 = -2;
//         return;
//     endif;

//     alias openFileTableEntry R8;
//     openFileTableEntry = OPEN_FILE_TABLE + openFileTableIndex*4;

//     // --- If file to open is Root File --------
//     if(fileName == "root") then
//         [openFileTableEntry + 0] = INODE_ROOT;
//     else
//         //------- Update FILE STATUS TABLE Entry  ----------------
//         alias fileStatusEntry R7;
//         fileStatusEntry = FILE_STATUS_TABLE + inodeTableIndex*4;
//         // Setting Open File Count
//         if([fileStatusEntry + 1] == -1) then 
//             [fileStatusEntry + 1] = 1;
//         else
//             [fileStatusEntry + 1] = [fileStatusEntry + 1] + 1;
//         endif;
//         // ---- INODE INDEX Field of OPEN FILE TABLE set -----------
//         [openFileTableEntry + 0] = inodeTableIndex;   // Inode Index
//     endif;

//     // ---- OPEN FILE TABLE setup --------------
//     [openFileTableEntry + 1] = 1;     // Open Instance Count
//     [openFileTableEntry + 2] = 0;     // LSEEK


//     // --- Call Release_Inode() and Return Open File Table Index----------------
//     // Calling Release_Inode() Resource Manager
//     // Args:
//     // funNum = 5, inodeTableIndex, PID
//     multipush(R1,R2,R3,R5,R6,R7,R8);
//         R1 = 5;
//         R2 = inodeTableIndex;
//         R3 = [SYSTEM_STATUS_TABLE + 1];
//         call MOD_0;
//     multipop(R1,R2,R3,R5,R6,R7,R8);
//     R0 = openFileTableIndex;
//     return;

// endif;


// // ------ CLOSE (funNum = 4) -------------------------------------------
// // Update the file status table and 
// // the open file table when a file is opened
// // Args: 
// // 1. open file table index
// // Returns: NIL
// if( functionNum == 4 ) then
//     // Args:
//     alias openFileTableIndex R2;

//     alias openFileTableEntry R5;
//     openFileTableEntry = OPEN_FILE_TABLE + openFileTableIndex*4;
//     alias inodeindex R6;
//     inodeindex = [openFileTableEntry];

//     // Decrement Open Instance Count in Open File Table
//     [openFileTableEntry + 1] = [openFileTableEntry + 1] - 1;
    
//     if( [openFileTableEntry + 1] == 0) then
//         // if Open Instance Count becomes Zero:
//         // Inavildate the Open file Table Entry
//         [openFileTableEntry] = -1;       // Inode Index
//         [openFileTableEntry + 1] = -1;   // Open Instance Count
//         [openFileTableEntry + 2] = -1;   // LSEEK

//         // if file is not ROOT, decr the FILE OPEN COUNT in File Status Table
//         if([INODE_TABLE + inodeindex*16 + 1] != "root") then
//             [FILE_STATUS_TABLE + inodeindex*4 + 1] = [FILE_STATUS_TABLE + inodeindex*4 + 1] - 1;
//         endif;
//         if([FILE_STATUS_TABLE + inodeindex*4 + 1] == 0) then
//             // if File Open Count becomes Zero
//             [FILE_STATUS_TABLE + inodeindex*4 + 1] = -1;
//         endif;
//     endif;
//     return;
// endif;

// // ------------------------------------------------------------------------------------------------
// print("WrongFunctionNum");
// return;
