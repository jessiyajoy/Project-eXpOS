//---- SYSTEM CALLS :

//1. CREATE SYSTEM CALL
//4. DELETE SYSTEM CALL

alias syscallNum R15;
syscallNum = [([PTBR + 2 * ((SP - 5) / 512)] * 512) + ((SP - 5) % 512)];
alias userSP R5;
userSP = SP;

//--Switch Stack
//save user SP, set SP to KPTR
alias processEntry R14;
processEntry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16;

[processEntry + 13] = SP;
SP = [processEntry + 11] * 512 - 1;

//---CREATE SYSTEM CALL
//Args - Filename (String), Permission (0 - exclusive/1 - open-access)
//Return : 
//  0	Success/File already exists
// -1	No free inode table entry

if(syscallNum == 1) then

    // MODE
    [processEntry + 9] = 1;

    alias filename R6;
    filename = [([PTBR + 2*((userSP-4)/512)]*512) + ((userSP-4)%512)];


    //check if file already present
    alias cnt R7;
    cnt = 0;
    while( cnt < 60 ) do
        if( [INODE_TABLE + 16*cnt + 1] == filename ) then
            [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = 0;
            goto end;
        endif ;
        cnt = cnt + 1;
    endwhile ;

    //filename not already taken

    //find free entry in inode
    alias inodeIdx R8;
    cnt = 0;
    while( cnt < 60 ) do
        if( [INODE_TABLE + 16*cnt + 1] == -1 ) then
            inodeIdx = cnt;
            goto continue1;
        endif ;
        cnt = cnt + 1;
    endwhile;

    //no free entry return -1
    [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = -1;
    goto end;
    
    continue1 :
    // INODE TABLE
    // set FILE NAME to given file name, FILE SIZE to 0, FILE TYPE to DATA
    // USER ID to USERID of the process (process table)
    // PERMISSION to permission supplied as input
    //4 block numbers to -1

    alias userID R9;
    alias inodeEntry R10;
    alias rootEntry R11;
    userID = [processEntry + 3];
    inodeEntry = INODE_TABLE + 16*inodeIdx;
    rootEntry = ROOT_FILE + 8*inodeIdx;

    [inodeEntry + 0] = DATA;
    [inodeEntry + 1] = filename;
    [inodeEntry + 2] = 0;
    [inodeEntry + 3] = userID;
    [inodeEntry + 4] = [([PTBR + 2*((userSP-3)/512)]*512) + ((userSP-3)%512)];
    [inodeEntry + 8] = -1;
    [inodeEntry + 9] = -1;
    [inodeEntry + 10] = -1;
    [inodeEntry + 11] = -1;

    // ROOT FILE
    // FILE NAME, FILE SIZE, FILE TYPE, USERNAME and PERMISSION
    [rootEntry + 0] = filename;
    [rootEntry + 1] = 0;
    [rootEntry + 2] = DATA;
    [rootEntry + 3] = [USER_TABLE + 2*userID];
    [rootEntry + 4] = [inodeEntry + 4];
    
    [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = 0;
    goto end;
endif;



//---DELETE SYSTEM CALL
//Args - Filename (String)
//Return : 
//  0	Success/File does not exist
// -1	Permission denied
// -2	File is open

if(syscallNum == 4) then

    // MODE
    [processEntry + 9] = 4;

    alias filename R6;
    filename = [([PTBR + 2*((userSP-4)/512)]*512) + ((userSP-4)%512)];

    // find inode index of file
    alias cnt R7;
    cnt = 0;
    alias inodeIdx R8;
    while( cnt < 60 ) do
        if( [INODE_TABLE + 16*cnt + 1] == filename ) then
            inodeIdx = cnt;
            goto continue2;
        endif ;
        cnt = cnt + 1;
    endwhile ;

    //file not found return 0
    [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = 0;
    goto end;


    // file found
    continue2 :
    alias inodeEntry R13;
    inodeEntry = INODE_TABLE + 16*inodeIdx;
    //if file not DATA file return -1
    if( [inodeEntry + 0] != DATA ) then
        [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = -1;
        goto end;
    endif ;

    if([inodeEntry + 4] == EXCLUSIVE) then
        if( [processEntry + 3] == 1 || [processEntry + 3] == [inodeEntry + 3]) then
            goto continue3;
        endif ;
        // user has no permission to delete file, return -1
        [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = -1;
        goto end;
    endif;

    continue3 :
    // lock file
    // CALL ACQUIRE_INODE, RESOURCE MANAGER 0
    R1 = 4;
    R2 = inodeIdx;
    R3 = [SYSTEM_STATUS_TABLE+1];
    multipush(R5, R14, R6, R7, R8, R13);
    call MOD_0;
    multipop(R5, R14, R6, R7, R8, R13);

    //if file is open (file open count = -1 in File Status Table), cannot be deleted, return -2
    if( [FILE_STATUS_TABLE + 16*inodeIdx + 1] != -1 ) then
        // release lock on file
        // CALL RELEASE_INODE, RESOURCE MANAGER 0
        R1 = 5;
        R2 = inodeIdx;
        R3 = [SYSTEM_STATUS_TABLE+1];
        multipush(R5, R14, R6, R7, R8, R13);
        call MOD_0;
        multipop(R5, R14, R6, R7, R8, R13);
        [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = -2;
        goto end;
    endif;

    alias buffer_number R9;
    alias block_number R10;
    alias buffer_entry R11;
    cnt = 0;
    while( cnt < 4 ) do
        block_number = [inodeEntry + 8 + cnt];
        buffer_number =  block_number % 4;
        buffer_entry = BUFFER_TABLE + buffer_number*4;

        //if disk block is loaded into buffer and DIRTY BIT is set, reset dirty bit. 
        if([buffer_entry + 0] == block_number && [buffer_entry + 1] == 1) then
            [buffer_entry + 1] = 0;
        endif;

        // release disk block
        // CALL RELEASE_BLOCK, MEMORY MANAGER 2
        R1 = 4;
        R2 = block_number;
        R3 = [SYSTEM_STATUS_TABLE+1];
        multipush(R5, R14, R6, R7, R8, R9, R10, R11, R13);
        call MOD_2;
        multipop(R5, R14, R6, R7, R8, R9, R10, R11, R13);
        cnt = cnt + 1;
    endwhile ;

    // invalidate (filename of) inode entry and root file entry
    cnt = 0;
    while( cnt < 16 ) do
        [inodeEntry + cnt] = -1;
        cnt = cnt + 1;
    endwhile ;
    cnt = 0;
    while( cnt < 8 ) do
        [ROOT_FILE + 8*inodeIdx + cnt] = -1;
        cnt = cnt + 1;
    endwhile ;

    //release lock on file
    // CALL RELEASE_INODE, RESOURCE MANAGER 0
    R1 = 5;
    R2 = inodeIdx;
    R3 = [SYSTEM_STATUS_TABLE+1];
    multipush(R5, R14);
    call MOD_0;
    multipop(R5, R14);

    [([PTBR + 2*((userSP-1)/512)]*512) + ((userSP-1)%512)] = 0;    
    goto end;
endif;




end :
//switch stack, mode
SP = [processEntry + 13]; 
[processEntry + 9] = 0;

ireturn;