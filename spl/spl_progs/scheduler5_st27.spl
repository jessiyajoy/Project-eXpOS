//SWITCH CONTEXT 

//PID of currently process from System Status Table
alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE+1];

multipush(BP);

//find process Table entry of current process
alias process_table_entry R1;
process_table_entry = PROCESS_TABLE + currentPID * 16;

//Save KPTR, PTBR, PTLR to the Process Table entry of current process
[process_table_entry + 12] = SP % 512;
[process_table_entry + 14] = PTBR;
[process_table_entry + 15] = PTLR;

alias newPID R2;

if([SYSTEM_STATUS_TABLE+5] != 0) then
    if( [PROCESS_TABLE + 16*SWAPPER_DAEMON + 4] == WAIT_DISK) then
        newPID = IDLE_PROCESS;
    else
        newPID = SWAPPER_DAEMON;
    endif ;
else
    // ROUND ROBIN
    newPID = currentPID + 1;
    alias count R3;
    count = 1;
    while((count <= 16) && ([PROCESS_TABLE + (newPID*16) + 4] != READY) && ([PROCESS_TABLE + (newPID*16) + 4] != CREATED)) do
        newPID = ((newPID + 1)%16);
        count = count + 1;
    endwhile;

    if(count == 17) then
        newPID = 0;
endif;


endif;



alias new_process_table R3;
new_process_table = PROCESS_TABLE + newPID * 16;

//Set back Kernel SP, PTBR , PTLR
SP =  [new_process_table + 11] * 512 + [new_process_table + 12] ;
PTBR = [new_process_table + 14];
PTLR = [new_process_table + 15];

[SYSTEM_STATUS_TABLE + 1] = newPID;

if([new_process_table + 4] == CREATED) then
    BP = [SP];
    SP = [new_process_table + 13];
	[new_process_table + 4] = RUNNING;
    [new_process_table + 9] = 0;
	ireturn;
endif;
[new_process_table + 4] = RUNNING;
multipop(BP);
return;